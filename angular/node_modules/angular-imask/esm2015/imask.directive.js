/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Input, Output, forwardRef, Renderer2, EventEmitter, Optional, Inject, } from '@angular/core';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { ɵgetDOM as getDOM } from '@angular/platform-browser';
// TODO import only types when ts 3.8 released or when move IMask to ts
import IMask from 'imask';
/**
 * @return {?}
 */
function _isAndroid() {
    /** @type {?} */
    const userAgent = getDOM() ? getDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
/** @type {?} */
export const MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => IMaskDirective)),
    multi: true
};
/** @type {?} */
const DEFAULT_IMASK_ELEMENT = (/**
 * @param {?} elementRef
 * @return {?}
 */
(elementRef) => elementRef.nativeElement);
const ɵ0 = DEFAULT_IMASK_ELEMENT;
/**
 * @template Opts
 */
export class IMaskDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} _compositionMode
     */
    constructor(_elementRef, _renderer, _compositionMode) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._compositionMode = _compositionMode;
        // init here to support AOT (TODO may be will work with ng-packgr - need to check)
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
        this.onChange = (/**
         * @return {?}
         */
        () => { });
        this.imaskElement = DEFAULT_IMASK_ELEMENT;
        this.accept = new EventEmitter();
        this.complete = new EventEmitter();
        this._viewInitialized = false;
        this._composing = false;
        this._writing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    /**
     * @return {?}
     */
    get element() {
        return this.imaskElement(this._elementRef, this);
    }
    /**
     * @return {?}
     */
    get maskValue() {
        if (!this.maskRef)
            return this.element.value;
        if (this.unmask === 'typed')
            return this.maskRef.typedValue;
        if (this.unmask)
            return this.maskRef.unmaskedValue;
        return this.maskRef.value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maskValue(value) {
        if (this.maskRef) {
            if (this.unmask === 'typed')
                this.maskRef.typedValue = value;
            else if (this.unmask)
                this.maskRef.unmaskedValue = value;
            else
                this.maskRef.value = value;
        }
        else {
            this._renderer.setProperty(this.element, 'value', value);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.imask)
            this.initMask();
        this._viewInitialized = true;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.elementRef && !this.imaskElement)
            this.imaskElement = DEFAULT_IMASK_ELEMENT;
        if (!changes.imask || !this._viewInitialized)
            return;
        if (this.imask) {
            if (this.maskRef)
                this.maskRef.updateOptions(this.imask);
            else {
                this.initMask();
                this.onChange(this.maskValue);
            }
        }
        else {
            this.destroyMask();
        }
    }
    /**
     * @return {?}
     */
    destroyMask() {
        if (this.maskRef) {
            this.maskRef.destroy();
            delete this.maskRef;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyMask();
        this.accept.complete();
        this.complete.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    beginWrite(value) {
        this._writing = true;
        this._writingValue = value;
    }
    /**
     * @return {?}
     */
    endWrite() {
        this._writing = false;
        return this._writingValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        value = value == null ? '' : value;
        if (this.maskRef) {
            this.beginWrite(value);
            if (this.maskValue !== value ||
                // handle cases like Number('') === 0,
                // for details see https://github.com/uNmAnNeR/imaskjs/issues/134
                (typeof value !== 'string' && this.maskRef.value === '') &&
                    !this.maskRef.el.isActive) {
                this.maskValue = value;
            }
        }
        else {
            this._renderer.setProperty(this.element, 'value', value);
        }
    }
    /**
     * @return {?}
     */
    _onAccept() {
        /** @type {?} */
        const value = this.maskValue;
        // if value was not changed during writing don't fire events
        // for details see https://github.com/uNmAnNeR/imaskjs/issues/136
        if (this._writing && value === this.endWrite())
            return;
        this.onChange(value);
        this.accept.emit(value);
    }
    /**
     * @return {?}
     */
    _onComplete() {
        this.complete.emit(this.maskValue);
    }
    /**
     * @private
     * @return {?}
     */
    initMask() {
        this.maskRef = IMask(this.element, (/** @type {?} */ (this.imask)))
            .on('accept', this._onAccept.bind(this))
            .on('complete', this._onComplete.bind(this));
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this.element, 'disabled', isDisabled);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this.onChange = fn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this.onTouched = fn; }
    /**
     * @param {?} value
     * @return {?}
     */
    _handleInput(value) {
        // if mask is attached all input goes throw mask
        if (this.maskRef)
            return;
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this.onChange(value);
        }
    }
    /**
     * @return {?}
     */
    _compositionStart() { this._composing = true; }
    /**
     * @param {?} value
     * @return {?}
     */
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
}
IMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[imask]',
                host: {
                    '(input)': '_handleInput($event.target.value)',
                    '(blur)': 'onTouched()',
                    '(compositionstart)': '_compositionStart()',
                    '(compositionend)': '_compositionEnd($event.target.value)'
                },
                providers: [MASKEDINPUT_VALUE_ACCESSOR]
            },] }
];
/** @nocollapse */
IMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
];
IMaskDirective.propDecorators = {
    imask: [{ type: Input }],
    unmask: [{ type: Input }],
    imaskElement: [{ type: Input }],
    accept: [{ type: Output }],
    complete: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    IMaskDirective.prototype.maskRef;
    /** @type {?} */
    IMaskDirective.prototype.onTouched;
    /** @type {?} */
    IMaskDirective.prototype.onChange;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._viewInitialized;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._composing;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._writingValue;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._writing;
    /** @type {?} */
    IMaskDirective.prototype.imask;
    /** @type {?} */
    IMaskDirective.prototype.unmask;
    /** @type {?} */
    IMaskDirective.prototype.imaskElement;
    /** @type {?} */
    IMaskDirective.prototype.accept;
    /** @type {?} */
    IMaskDirective.prototype.complete;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._compositionMode;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hc2suZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1pbWFzay8iLCJzb3VyY2VzIjpbImltYXNrLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQVksU0FBUyxFQUNyRSxZQUFZLEVBQ1osUUFBUSxFQUFFLE1BQU0sR0FDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUF3Qix1QkFBdUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2xHLE9BQU8sRUFBRSxPQUFPLElBQUksTUFBTSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7O0FBRTlELE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQzs7OztBQUcxQixTQUFTLFVBQVU7O1VBQ1gsU0FBUyxHQUFHLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtJQUN6RCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDdkQsQ0FBQzs7QUFHRCxNQUFNLE9BQU8sMEJBQTBCLEdBQWE7SUFDbEQsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVTs7O0lBQUMsR0FBRyxFQUFFLENBQUMsY0FBYyxFQUFDO0lBQzdDLEtBQUssRUFBRSxJQUFJO0NBQ1o7O01BRUsscUJBQXFCOzs7O0FBQUcsQ0FBQyxVQUFlLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUE7Ozs7O0FBVzNFLE1BQU0sT0FBTyxjQUFjOzs7Ozs7SUFlekIsWUFBb0IsV0FBdUIsRUFDdkIsU0FBb0IsRUFDeUIsZ0JBQXlCO1FBRnRFLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ3ZCLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDeUIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFTO1FBQ3hGLGtGQUFrRjtRQUNsRixJQUFJLENBQUMsU0FBUzs7O1FBQUcsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFBLENBQUM7UUFDMUIsSUFBSSxDQUFDLFFBQVE7OztRQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxZQUFZLEdBQUcscUJBQXFCLENBQUM7UUFDMUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1FBQzlCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBRXRCLElBQUksSUFBSSxDQUFDLGdCQUFnQixJQUFJLElBQUksRUFBRTtZQUNqQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUN2QztJQUNILENBQUM7Ozs7SUFFRCxJQUFJLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuRCxDQUFDOzs7O0lBRUQsSUFBSSxTQUFTO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPO1lBQUUsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztRQUU3QyxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssT0FBTztZQUFFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7UUFDNUQsSUFBSSxJQUFJLENBQUMsTUFBTTtZQUFFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDbkQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztJQUM1QixDQUFDOzs7OztJQUVELElBQUksU0FBUyxDQUFFLEtBQVU7UUFDdkIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxPQUFPO2dCQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztpQkFDeEQsSUFBSSxJQUFJLENBQUMsTUFBTTtnQkFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7O2dCQUNwRCxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7U0FDakM7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzFEO0lBQ0gsQ0FBQzs7OztJQUVELGVBQWU7UUFDYixJQUFJLElBQUksQ0FBQyxLQUFLO1lBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWhDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7SUFDL0IsQ0FBQzs7Ozs7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxPQUFPLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVk7WUFBRSxJQUFJLENBQUMsWUFBWSxHQUFHLHFCQUFxQixDQUFDO1FBRXhGLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQjtZQUFFLE9BQU87UUFFckQsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2QsSUFBSSxJQUFJLENBQUMsT0FBTztnQkFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3BEO2dCQUNILElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDL0I7U0FDRjthQUFNO1lBQ0wsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQzs7OztJQUVELFdBQVc7UUFDVCxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN2QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7U0FDckI7SUFDSCxDQUFDOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDM0IsQ0FBQzs7Ozs7SUFFRCxVQUFVLENBQUUsS0FBVTtRQUNwQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNyQixJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztJQUM3QixDQUFDOzs7O0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM1QixDQUFDOzs7OztJQUVELFVBQVUsQ0FBQyxLQUFVO1FBQ25CLEtBQUssR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUVuQyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUV2QixJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssS0FBSztnQkFDMUIsc0NBQXNDO2dCQUN0QyxpRUFBaUU7Z0JBQ2pFLENBQUMsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxLQUFLLEVBQUUsQ0FBQztvQkFDdEQsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQzNCO2dCQUNBLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO2FBQ3hCO1NBQ0Y7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzFEO0lBQ0gsQ0FBQzs7OztJQUVELFNBQVM7O2NBQ0QsS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTO1FBQzVCLDREQUE0RDtRQUM1RCxpRUFBaUU7UUFDakUsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQUUsT0FBTztRQUN2RCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFCLENBQUM7Ozs7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Ozs7O0lBRU8sUUFBUTtRQUNkLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsbUJBQUEsSUFBSSxDQUFDLEtBQUssRUFBUSxDQUFDO2FBQ25ELEVBQUUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdkMsRUFBRSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2pELENBQUM7Ozs7O0lBRUQsZ0JBQWdCLENBQUUsVUFBbUI7UUFDbkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUE7SUFDbEUsQ0FBQzs7Ozs7SUFFRCxnQkFBZ0IsQ0FBQyxFQUFvQixJQUFVLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFBLENBQUMsQ0FBQzs7Ozs7SUFDbkUsaUJBQWlCLENBQUMsRUFBYyxJQUFVLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFBLENBQUMsQ0FBQzs7Ozs7SUFFL0QsWUFBWSxDQUFDLEtBQVU7UUFDckIsZ0RBQWdEO1FBQ2hELElBQUksSUFBSSxDQUFDLE9BQU87WUFBRSxPQUFPO1FBRXpCLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDekUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0QjtJQUNILENBQUM7Ozs7SUFFRCxpQkFBaUIsS0FBVyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7Ozs7O0lBRXJELGVBQWUsQ0FBQyxLQUFVO1FBQ3hCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3BELENBQUM7OztZQXpLRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLFNBQVM7Z0JBQ25CLElBQUksRUFBRTtvQkFDSixTQUFTLEVBQUUsbUNBQW1DO29CQUM5QyxRQUFRLEVBQUUsYUFBYTtvQkFDdkIsb0JBQW9CLEVBQUUscUJBQXFCO29CQUMzQyxrQkFBa0IsRUFBRSxzQ0FBc0M7aUJBQzNEO2dCQUNELFNBQVMsRUFBRSxDQUFDLDBCQUEwQixDQUFDO2FBQ3hDOzs7O1lBaENZLFVBQVU7WUFBdUMsU0FBUzswQ0FrRHhELFFBQVEsWUFBSSxNQUFNLFNBQUMsdUJBQXVCOzs7b0JBUnRELEtBQUs7cUJBQ0wsS0FBSzsyQkFDTCxLQUFLO3FCQUNMLE1BQU07dUJBQ04sTUFBTTs7OztJQVpQLGlDQUFnQzs7SUFDaEMsbUNBQWU7O0lBQ2Ysa0NBQWM7Ozs7O0lBQ2QsMENBQWtDOzs7OztJQUNsQyxvQ0FBNEI7Ozs7O0lBQzVCLHVDQUEyQjs7Ozs7SUFDM0Isa0NBQTBCOztJQUUxQiwrQkFBc0I7O0lBQ3RCLGdDQUFrQzs7SUFDbEMsc0NBQXdGOztJQUN4RixnQ0FBb0M7O0lBQ3BDLGtDQUFzQzs7Ozs7SUFFMUIscUNBQStCOzs7OztJQUMvQixtQ0FBNEI7Ozs7O0lBQzVCLDBDQUE4RSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT3V0cHV0LCBmb3J3YXJkUmVmLCBQcm92aWRlciwgUmVuZGVyZXIyLFxyXG4gIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsXHJcbiAgT3B0aW9uYWwsIEluamVjdCwgU2ltcGxlQ2hhbmdlcyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IsIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBDT01QT1NJVElPTl9CVUZGRVJfTU9ERSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgybVnZXRET00gYXMgZ2V0RE9NIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XHJcbi8vIFRPRE8gaW1wb3J0IG9ubHkgdHlwZXMgd2hlbiB0cyAzLjggcmVsZWFzZWQgb3Igd2hlbiBtb3ZlIElNYXNrIHRvIHRzXHJcbmltcG9ydCBJTWFzayBmcm9tICdpbWFzayc7XHJcblxyXG5cclxuZnVuY3Rpb24gX2lzQW5kcm9pZCgpOiBib29sZWFuIHtcclxuICBjb25zdCB1c2VyQWdlbnQgPSBnZXRET00oKSA/IGdldERPTSgpLmdldFVzZXJBZ2VudCgpIDogJyc7XHJcbiAgcmV0dXJuIC9hbmRyb2lkIChcXGQrKS8udGVzdCh1c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgTUFTS0VESU5QVVRfVkFMVUVfQUNDRVNTT1I6IFByb3ZpZGVyID0ge1xyXG4gIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElNYXNrRGlyZWN0aXZlKSxcclxuICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5cclxuY29uc3QgREVGQVVMVF9JTUFTS19FTEVNRU5UID0gKGVsZW1lbnRSZWY6IGFueSkgPT4gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tpbWFza10nLFxyXG4gIGhvc3Q6IHtcclxuICAgICcoaW5wdXQpJzogJ19oYW5kbGVJbnB1dCgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXHJcbiAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyxcclxuICAgICcoY29tcG9zaXRpb25zdGFydCknOiAnX2NvbXBvc2l0aW9uU3RhcnQoKScsXHJcbiAgICAnKGNvbXBvc2l0aW9uZW5kKSc6ICdfY29tcG9zaXRpb25FbmQoJGV2ZW50LnRhcmdldC52YWx1ZSknXHJcbiAgfSxcclxuICBwcm92aWRlcnM6IFtNQVNLRURJTlBVVF9WQUxVRV9BQ0NFU1NPUl1cclxufSlcclxuZXhwb3J0IGNsYXNzIElNYXNrRGlyZWN0aXZlPE9wdHMgZXh0ZW5kcyBJTWFzay5BbnlNYXNrZWRPcHRpb25zPiBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XHJcbiAgbWFza1JlZj86IElNYXNrLklucHV0TWFzazxPcHRzPjtcclxuICBvblRvdWNoZWQ6IGFueTtcclxuICBvbkNoYW5nZTogYW55O1xyXG4gIHByaXZhdGUgX3ZpZXdJbml0aWFsaXplZDogYm9vbGVhbjtcclxuICBwcml2YXRlIF9jb21wb3Npbmc6IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSBfd3JpdGluZ1ZhbHVlOiBhbnk7XHJcbiAgcHJpdmF0ZSBfd3JpdGluZzogYm9vbGVhbjtcclxuXHJcbiAgQElucHV0KCkgaW1hc2s/OiBPcHRzO1xyXG4gIEBJbnB1dCgpIHVubWFzaz86IGJvb2xlYW58J3R5cGVkJztcclxuICBASW5wdXQoKSBpbWFza0VsZW1lbnQ6IChlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBkaXJlY3RpdmVSZWY6IGFueSkgPT4gSU1hc2suTWFza0VsZW1lbnQ7XHJcbiAgQE91dHB1dCgpIGFjY2VwdDogRXZlbnRFbWl0dGVyPGFueT47XHJcbiAgQE91dHB1dCgpIGNvbXBsZXRlOiBFdmVudEVtaXR0ZXI8YW55PjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgICAgICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxyXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoQ09NUE9TSVRJT05fQlVGRkVSX01PREUpIHByaXZhdGUgX2NvbXBvc2l0aW9uTW9kZTogYm9vbGVhbikge1xyXG4gICAgLy8gaW5pdCBoZXJlIHRvIHN1cHBvcnQgQU9UIChUT0RPIG1heSBiZSB3aWxsIHdvcmsgd2l0aCBuZy1wYWNrZ3IgLSBuZWVkIHRvIGNoZWNrKVxyXG4gICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7fTtcclxuICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7fTtcclxuICAgIHRoaXMuaW1hc2tFbGVtZW50ID0gREVGQVVMVF9JTUFTS19FTEVNRU5UO1xyXG4gICAgdGhpcy5hY2NlcHQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB0aGlzLmNvbXBsZXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgdGhpcy5fdmlld0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuX3dyaXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAodGhpcy5fY29tcG9zaXRpb25Nb2RlID09IG51bGwpIHtcclxuICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlID0gIV9pc0FuZHJvaWQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBlbGVtZW50ICgpIHtcclxuICAgIHJldHVybiB0aGlzLmltYXNrRWxlbWVudCh0aGlzLl9lbGVtZW50UmVmLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIGdldCBtYXNrVmFsdWUgKCk6IGFueSB7XHJcbiAgICBpZiAoIXRoaXMubWFza1JlZikgcmV0dXJuIHRoaXMuZWxlbWVudC52YWx1ZTtcclxuXHJcbiAgICBpZiAodGhpcy51bm1hc2sgPT09ICd0eXBlZCcpIHJldHVybiB0aGlzLm1hc2tSZWYudHlwZWRWYWx1ZTtcclxuICAgIGlmICh0aGlzLnVubWFzaykgcmV0dXJuIHRoaXMubWFza1JlZi51bm1hc2tlZFZhbHVlO1xyXG4gICAgcmV0dXJuIHRoaXMubWFza1JlZi52YWx1ZTtcclxuICB9XHJcblxyXG4gIHNldCBtYXNrVmFsdWUgKHZhbHVlOiBhbnkpIHtcclxuICAgIGlmICh0aGlzLm1hc2tSZWYpIHtcclxuICAgICAgaWYgKHRoaXMudW5tYXNrID09PSAndHlwZWQnKSB0aGlzLm1hc2tSZWYudHlwZWRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICBlbHNlIGlmICh0aGlzLnVubWFzaykgdGhpcy5tYXNrUmVmLnVubWFza2VkVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgZWxzZSB0aGlzLm1hc2tSZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgaWYgKHRoaXMuaW1hc2spIHRoaXMuaW5pdE1hc2soKTtcclxuXHJcbiAgICB0aGlzLl92aWV3SW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgaWYgKGNoYW5nZXMuZWxlbWVudFJlZiAmJiAhdGhpcy5pbWFza0VsZW1lbnQpIHRoaXMuaW1hc2tFbGVtZW50ID0gREVGQVVMVF9JTUFTS19FTEVNRU5UO1xyXG5cclxuICAgIGlmICghY2hhbmdlcy5pbWFzayB8fCAhdGhpcy5fdmlld0luaXRpYWxpemVkKSByZXR1cm47XHJcblxyXG4gICAgaWYgKHRoaXMuaW1hc2spIHtcclxuICAgICAgaWYgKHRoaXMubWFza1JlZikgdGhpcy5tYXNrUmVmLnVwZGF0ZU9wdGlvbnModGhpcy5pbWFzayk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaW5pdE1hc2soKTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMubWFza1ZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5kZXN0cm95TWFzaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveU1hc2sgKCkge1xyXG4gICAgaWYgKHRoaXMubWFza1JlZikge1xyXG4gICAgICB0aGlzLm1hc2tSZWYuZGVzdHJveSgpO1xyXG4gICAgICBkZWxldGUgdGhpcy5tYXNrUmVmO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3kgKCkge1xyXG4gICAgdGhpcy5kZXN0cm95TWFzaygpO1xyXG4gICAgdGhpcy5hY2NlcHQuY29tcGxldGUoKTtcclxuICAgIHRoaXMuY29tcGxldGUuY29tcGxldGUoKTtcclxuICB9XHJcblxyXG4gIGJlZ2luV3JpdGUgKHZhbHVlOiBhbnkpOiB2b2lkIHtcclxuICAgIHRoaXMuX3dyaXRpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5fd3JpdGluZ1ZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBlbmRXcml0ZSAoKTogYW55IHtcclxuICAgIHRoaXMuX3dyaXRpbmcgPSBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzLl93cml0aW5nVmFsdWU7XHJcbiAgfVxyXG5cclxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcclxuICAgIHZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcblxyXG4gICAgaWYgKHRoaXMubWFza1JlZikge1xyXG4gICAgICB0aGlzLmJlZ2luV3JpdGUodmFsdWUpO1xyXG5cclxuICAgICAgaWYgKHRoaXMubWFza1ZhbHVlICE9PSB2YWx1ZSB8fFxyXG4gICAgICAgIC8vIGhhbmRsZSBjYXNlcyBsaWtlIE51bWJlcignJykgPT09IDAsXHJcbiAgICAgICAgLy8gZm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91Tm1Bbk5lUi9pbWFza2pzL2lzc3Vlcy8xMzRcclxuICAgICAgICAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0aGlzLm1hc2tSZWYudmFsdWUgPT09ICcnKSAmJlxyXG4gICAgICAgICAgIXRoaXMubWFza1JlZi5lbC5pc0FjdGl2ZVxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLm1hc2tWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vbkFjY2VwdCAoKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMubWFza1ZhbHVlO1xyXG4gICAgLy8gaWYgdmFsdWUgd2FzIG5vdCBjaGFuZ2VkIGR1cmluZyB3cml0aW5nIGRvbid0IGZpcmUgZXZlbnRzXHJcbiAgICAvLyBmb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3VObUFuTmVSL2ltYXNranMvaXNzdWVzLzEzNlxyXG4gICAgaWYgKHRoaXMuX3dyaXRpbmcgJiYgdmFsdWUgPT09IHRoaXMuZW5kV3JpdGUoKSkgcmV0dXJuO1xyXG4gICAgdGhpcy5vbkNoYW5nZSh2YWx1ZSk7XHJcbiAgICB0aGlzLmFjY2VwdC5lbWl0KHZhbHVlKTtcclxuICB9XHJcblxyXG4gIF9vbkNvbXBsZXRlICgpIHtcclxuICAgIHRoaXMuY29tcGxldGUuZW1pdCh0aGlzLm1hc2tWYWx1ZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGluaXRNYXNrICgpIHtcclxuICAgIHRoaXMubWFza1JlZiA9IElNYXNrKHRoaXMuZWxlbWVudCwgdGhpcy5pbWFzayBhcyBPcHRzKVxyXG4gICAgICAub24oJ2FjY2VwdCcsIHRoaXMuX29uQWNjZXB0LmJpbmQodGhpcykpXHJcbiAgICAgIC5vbignY29tcGxldGUnLCB0aGlzLl9vbkNvbXBsZXRlLmJpbmQodGhpcykpO1xyXG4gIH1cclxuXHJcbiAgc2V0RGlzYWJsZWRTdGF0ZSAoaXNEaXNhYmxlZDogYm9vbGVhbikge1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKVxyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQgeyB0aGlzLm9uQ2hhbmdlID0gZm4gfVxyXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7IHRoaXMub25Ub3VjaGVkID0gZm4gfVxyXG5cclxuICBfaGFuZGxlSW5wdXQodmFsdWU6IGFueSk6IHZvaWQge1xyXG4gICAgLy8gaWYgbWFzayBpcyBhdHRhY2hlZCBhbGwgaW5wdXQgZ29lcyB0aHJvdyBtYXNrXHJcbiAgICBpZiAodGhpcy5tYXNrUmVmKSByZXR1cm47XHJcblxyXG4gICAgaWYgKCF0aGlzLl9jb21wb3NpdGlvbk1vZGUgfHwgKHRoaXMuX2NvbXBvc2l0aW9uTW9kZSAmJiAhdGhpcy5fY29tcG9zaW5nKSkge1xyXG4gICAgICB0aGlzLm9uQ2hhbmdlKHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jb21wb3NpdGlvblN0YXJ0KCk6IHZvaWQgeyB0aGlzLl9jb21wb3NpbmcgPSB0cnVlOyB9XHJcblxyXG4gIF9jb21wb3NpdGlvbkVuZCh2YWx1ZTogYW55KTogdm9pZCB7XHJcbiAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuX2NvbXBvc2l0aW9uTW9kZSAmJiB0aGlzLl9oYW5kbGVJbnB1dCh2YWx1ZSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==